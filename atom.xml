<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[毁灭阴影]]></title>
  <subtitle><![CDATA[程序员 先天性失乐症患者 手SF的逗比]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://SFKong.github.com/"/>
  <updated>2014-05-06T03:30:12.380Z</updated>
  <id>http://SFKong.github.com/</id>
  
  <author>
    <name><![CDATA[Misery]]></name>
    <email><![CDATA[715616554@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Objective-C中属性@property中atomic的实现]]></title>
    <link href="http://SFKong.github.com/2014/04/27/objective-c%E4%B8%AD%E5%B1%9E%E6%80%A7@property%E4%B8%ADatomic%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://SFKong.github.com/2014/04/27/objective-c中属性@property中atomic的实现/</id>
    <published>2014-04-27T14:15:36.000Z</published>
    <updated>2014-04-27T15:20:52.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C中，属性@property默认是线程不安全的，也就是常见的nonatomic，这个时候，如果多个线程同时操作这个属性就可能会出现问题，这时需要设置属性为atomic，当然也可以通过代码来控制线程安全；</p>
<ul>
<li>使用@synchronized<br>这种方法是使用苹果提供的“synchronization block”来实现，</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (void)synchronizedMethod
{
    <span class="variable">@synchronized</span>(<span class="keyword">self</span>){
        <span class="regexp">//</span>线程安全代码
    }
}
</pre></td></tr></table></figure>

<p>这个方法根据给定的self对象创建锁，等待{}中的代码执行完毕，释放锁，这种写法会面临效率问题，如果在同一个类中多处使用了这个写法，这些地方的代码都需要按顺序执行，虽然有可能这些方法并不相关。<br>－ 使用NSLock<br>通过创建NSLock对象来进行同步操作，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>_lock = [[NSLock alloc] init];
- (<span class="keyword">void</span>)synchronizedMethod
{
    [_lock <span class="keyword">lock</span>];
    <span class="comment">//线程安全代码</span>
    [_lock unlock];
}
</pre></td></tr></table></figure>

<p>这里的NSLock保证了代码在的线程安全，另一种NSRecursiveLock用法类似，不过线程可以多次持有该锁。<br>以上两种方式，在某些情况下会出现死锁，效率也不一定高，下面就是本文的重点了，使用GCD来实现更加高效简单的代码加锁<br>－ 使用GCD<br>创建串行队列，将代码放在串行队列中执行保证线程安全。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>_syncQueue = dispatch_queue_create(<span class="string">"io.sfkong"</span>, <span class="literal">NULL</span>);
- (<span class="keyword">void</span>)synchronizedMethod
{
    <span class="built_in">dispatch_sync</span>(_syncQueue, ^{
       <span class="comment">//线程安全代码</span>
    });
}
</pre></td></tr></table></figure>

<p>这个操作放在setter和getter里面再合适不过了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>- (<span class="built_in">NSString</span> *)someString
{
    __block <span class="built_in">NSString</span> *localSomeString;
    <span class="built_in">dispatch_sync</span>(_syncQueue, ^{
        localSomeString = _someString;
    });
    <span class="keyword">return</span> localSomeString;
}
- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString
{
    <span class="built_in">dispatch_sync</span>(_syncQueue, ^{
        _someString = someString;
    });
}
</pre></td></tr></table></figure>

<p>将属性操作放在串行队列中，所有针对属性的操作都同步了。另GCD的底层实现，使得这段代码的优化更好，开发者也无需担心代码的优化问题。</p>
<ul>
<li>进一步优化<br>由于setter不需要立刻返回，可以将以上setter里面的同步函数换成异步dispatch_async，来进一步提升性能，当然这样也是有代价的，异步函数会对block进行拷贝，如果block中代码执行的速度快于block的拷贝速度，则还是选择dispatch_sync来执行代码，所以具体问题具体分析，选择合适的函数来执行。</li>
<li>将优化进行到底<br>通常，多个getter之间是可以并发执行的，而setter和getter之间是不允许并发执行，利用这个特点，可以写出速度更快的代码，使用NSLock很难实现，这时GCD的好处就体现出来了：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);
- (<span class="built_in">NSString</span> *)someString
{
    __block <span class="built_in">NSString</span> *localSomeString;
    <span class="built_in">dispatch_sync</span>(_syncQueue, ^{
        localSomeString = _someString;
    });
    <span class="keyword">return</span> localSomeString;
}
- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString
{
    dispatch_barrier_sync(_syncQueue, ^{
        _someString = someString;
    });
}
</pre></td></tr></table></figure>

<p>这里使用并发队列，getter可以被随时调用不会出现锁的问题，setter方法使用栅栏(barrier)来进行保护，保证setter的线程安全；代码跑得飞快有木有</p>
<blockquote>
<p>参考《Effective Objective-C》，如有雷同，纯属本文抄袭！！</p>
</blockquote>
]]></content>
    
    
      <category term="同步锁" scheme="http://SFKong.github.com/tags/%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    
      <category term="GCD" scheme="http://SFKong.github.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用GCD替换performSelector这一类方法]]></title>
    <link href="http://SFKong.github.com/2014/04/27/mrc%E5%92%8Carc%E4%B8%ADblock%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://SFKong.github.com/2014/04/27/mrc和arc中block的内存管理/</id>
    <published>2014-04-27T11:54:44.000Z</published>
    <updated>2014-04-27T15:22:03.000Z</updated>
    <content type="html"><![CDATA[<p>在Objective-C中有这样一类方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(aa) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1</span>];
    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(aa) onThread:[<span class="built_in">NSThread</span> mainThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];
</pre></td></tr></table></figure>

<p>这一系列方法可以将执行时间推迟，也可以指定执行的线程。在引入GCD以后，这些方法就可以使用GCD来替换;<br>例如上面的两个方法就可以这么写:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="function">dispatch_after(<span class="function">dispatch_time(DISPATCH_TIME_NOW, (int64_t)</span>(<span class="number">1</span> * NSEC_PER_SEC)</span>), <span class="function">dispatch_get_main_queue()</span>, ^{
        <span class="attr_selector">[self aa]</span>;
    });
    <span class="function">dispatch_async(<span class="function">dispatch_get_main_queue()</span>, ^{
        [self aa];
    })</span>;
</pre></td></tr></table></figure>

<p>好处就是，可以避免performSelector这一类方法带来的内存警告：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>warning:performSelector may cause a leak because its selector is unknown <span class="preprocessor">[</span><span class="attribute">-Warc</span><span class="attribute">-performSelector</span><span class="attribute">-leaks</span><span class="preprocessor">]</span><span class="markup"></span>
</pre></td></tr></table></figure>

<p>更重要的是，使用GCD逼格更高！！！</p>
]]></content>
    
    
      <category term="GCD" scheme="http://SFKong.github.com/tags/GCD/"/>
    
      <category term="block" scheme="http://SFKong.github.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xcode更新到5.1报错：Cast from pointer to smaller type 'int' loses information]]></title>
    <link href="http://SFKong.github.com/2014/04/22/xcode%E6%9B%B4%E6%96%B0%E5%88%B051%E6%8A%A5%E9%94%99%EF%BC%9Acast-from-pointer-to-smaller-type-int-loses-information/"/>
    <id>http://SFKong.github.com/2014/04/22/xcode更新到51报错：cast-from-pointer-to-smaller-type-int-loses-information/</id>
    <published>2014-04-22T03:42:46.000Z</published>
    <updated>2014-04-27T15:21:50.000Z</updated>
    <content type="html"><![CDATA[<p>Xcode更新到5.1版本之后，项目中一个SearchCore文件报错</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Cast <span class="keyword">from</span> pointer <span class="keyword">to</span> smaller <span class="keyword">type</span> <span class="string">'int'</span> loses information
</pre></td></tr></table></figure>

<p>由于5.1编译包括了arm64，导致指针大小长度编程8字节。<br>解决方法：<br>修改target的build setting中的Architectures,删除$(ARCHS_STANDARD)，添加armv7和armv7s，重新编译即可</p>
]]></content>
    
    
      <category term="xcode" scheme="http://SFKong.github.com/tags/xcode/"/>
    
  </entry>
  
</feed>
